很多程序员的安全感，来自“防御性编程”。

但我要说一句刺耳的：

**在AI时代，防御性编程正在让你贬值。**

## 一、防御性编程，其实分三种

### ① 正常工程防御（合理）

- 参数校验
- 异常处理
- 解耦设计

这是工程基本功，没问题。

### ② 被动型防御（自保式）

- 过度抽象
- 结构复杂化
- 故意提高理解门槛
- “没有我不敢改”

本质不是为系统，是为自己。制造依赖，制造不可替代。

### ③ 主动型防御（攻击性）

- 留后门
- 逻辑炸弹
- 隐性依赖
- 数据投毒

这已经不是技术问题，是法律问题。

很多人低估了这一点。这是刑事风险，不是职场策略。

## 二、观点一：AI理解代码，老旧代码不再是护城河

过去，复杂系统=壁垒。

代码越老越绕，你越安全。

但现在：

AI可以自动生成结构图
 自动分析调用链
 自动梳理依赖
 自动给重构建议

以前新人两个月才能摸清系统，现在两小时。

你守着复杂性，以为是护城河。

在AI眼里，只是待解析文本。

**代码理解成本正在被压缩。复杂，不再等于价值。**

## 三、观点二：防御性编程，让你失去成长机会

防御型程序员每天都很忙：

null判断
异常捕获
极端场景覆盖
提前设计“未来扩展”

但组织真正关心的是：

这个系统还值不值得存在？
是否应该推倒重来？
架构是否过度设计？
业务是否该收缩？

这些问题，不在代码层。在决策层。

如果你长期沉迷“技术正确”，
你会错过“方向正确”。

真正值钱的能力，是在不确定中做判断。不是在确定性里加判断。

## 四、观点三：主动防御，会毁掉你的职业

有些人会想：

“留个后门也不过分吧？”
 “万一哪天被裁呢？”

这是极其危险的思维。

一旦被发现：

职业信用直接归零
行业口碑永久损毁
严重的触犯刑法

技术行业最贵的资产是什么？

不是代码。是信任。

主动防御，本质是自毁。

## 一个残酷的真相

防御给你安全感。承担不确定性，才给你未来。

最危险的程序员不是能力差的。

而是那些以为自己在构建护城河，其实在构建牢笼的人。